// Generated by CoffeeScript 1.3.1
/* @preserve
 * ====================================================================
 * jsPDF
 * Copyright (c) 2010 James Hall, https://github.com/MrRio/jsPDF
 * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
 * Copyright (c) 2012 Jason Siefken https://github.com/siefkenj/jsPDF
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
*/

/*
# Some utility functions
*/

var Dictionary, PdfArray, PdfContex, PdfImage, PdfObject, Reference, ReferenceFactory, base64encode, getISODate, getJpegSize, getStyle, jsPDF, jsPDFOriginalAPI, parseColor, parseFont, pdfEscape, root, round2, round3, typeOf,
  __slice = [].slice;

getISODate = function() {
  var padd2, today;
  padd2 = function(num) {
    var ret;
    ret = num.toFixed(0);
    if (ret.length >= 2) {
      return ret;
    } else {
      return '0' + ret;
    }
  };
  today = new Date;
  return "" + (today.getFullYear()) + (padd2(today.getMonth() + 1)) + (padd2(today.getDate())) + (padd2(today.getHours())) + (padd2(today.getMinutes())) + (padd2(today.getSeconds()));
};

base64encode = btoa || function(data) {
  /* @preserve
  ====================================================================
  base64 encoder
  MIT, GPL
  
  version: 1109.2015
  discuss at: http://phpjs.org/functions/base64_encode
  +   original by: Tyler Akins (http://rumkin.com)
  +   improved by: Bayron Guevara
  +   improved by: Thunder.m
  +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  +   bugfixed by: Pellentesque Malesuada
  +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  +   improved by: Rafal Kukawski (http://kukawski.pl)
  ====================================================================
  */

  var ac, b64, b64a, bits, enc, h1, h2, h3, h4, i, o1, o2, o3, r, tmp_arr;
  b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  b64a = b64.split("");
  o1 = void 0;
  o2 = void 0;
  o3 = void 0;
  h1 = void 0;
  h2 = void 0;
  h3 = void 0;
  h4 = void 0;
  bits = void 0;
  i = 0;
  ac = 0;
  enc = "";
  tmp_arr = [];
  while (true) {
    o1 = data.charCodeAt(i++);
    o2 = data.charCodeAt(i++);
    o3 = data.charCodeAt(i++);
    bits = o1 << 16 | o2 << 8 | o3;
    h1 = bits >> 18 & 0x3f;
    h2 = bits >> 12 & 0x3f;
    h3 = bits >> 6 & 0x3f;
    h4 = bits & 0x3f;
    tmp_arr[ac++] = b64a[h1] + b64a[h2] + b64a[h3] + b64a[h4];
    if (!(i < data.length)) {
      break;
    }
  }
  enc = tmp_arr.join("");
  r = data.length % 3;
  return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3);
  /*
      end of base64 encoder MIT, GPL
  */

};

getJpegSize = function(imgData) {
  var blockLength, height, i, len, width;
  if (!imgData.charCodeAt(0) === 0xff || !imgData.charCodeAt(1) === 0xd8 || !imgData.charCodeAt(2) === 0xff || !imgData.charCodeAt(3) === 0xe0 || !imgData.charCodeAt(6) === "J".charCodeAt(0) || !imgData.charCodeAt(7) === "F".charCodeAt(0) || !imgData.charCodeAt(8) === "I".charCodeAt(0) || !imgData.charCodeAt(9) === "F".charCodeAt(0) || !imgData.charCodeAt(10) === 0x00) {
    throw new Error("getJpegSize requires a binary jpeg file");
  }
  blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);
  i = 4;
  len = imgData.length;
  while (i < len) {
    i += blockLength;
    if (imgData.charCodeAt(i) !== 0xff) {
      throw new Error("getJpegSize could not find the size of the image");
    }
    if (imgData.charCodeAt(i + 1) === 0xc0) {
      height = imgData.charCodeAt(i + 5) * 256 + imgData.charCodeAt(i + 6);
      width = imgData.charCodeAt(i + 7) * 256 + imgData.charCodeAt(i + 8);
      return [width, height];
    } else {
      i += 2;
      blockLength = imgData.charCodeAt(i) * 256 + imgData.charCodeAt(i + 1);
    }
  }
};

pdfEscape = function(str) {
  return str.replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
};

round3 = function(number) {
  if (typeOf(number) !== 'number') {
    number = Number(number);
  }
  return number.toFixed(3);
};

round2 = function(number) {
  if (typeOf(number) !== 'number') {
    number = Number(number);
  }
  return number.toFixed(2);
};

parseColor = function(color) {
  var c, colorStrings, m, ret;
  ret = [0, 0, 0];
  switch (typeOf(color)) {
    case 'string':
      if (color.charAt(0) === '#') {
        if (color.length === 4) {
          c = parseInt(color.charAt(1), 16);
          ret[0] = (c * 16 + c) / 255;
          c = parseInt(color.charAt(2), 16);
          ret[1] = (c * 16 + c) / 255;
          c = parseInt(color.charAt(3), 16);
          ret[2] = (c * 16 + c) / 255;
        }
        if (color.length === 7) {
          ret[0] = parseInt(color.slice(1, 3), 16) / 255;
          ret[1] = parseInt(color.slice(3, 5), 16) / 255;
          ret[2] = parseInt(color.slice(5, 7), 16) / 255;
        }
      }
      m = color.match(/\((.*)\)/);
      if (m != null) {
        colorStrings = m[1].split(',');
        ret[0] = parseInt(colorStrings[0], 10) / 255;
        ret[1] = parseInt(colorStrings[1], 10) / 255;
        ret[2] = parseInt(colorStrings[2], 10) / 255;
      }
      break;
    case 'array':
      if (Math.floor(color[0]) === color[0] && Math.floor(color[1]) === color[1] && Math.floor(color[2]) === color[2] && (color[0] !== 1 || color[1] !== 1 || color[2] !== 1)) {
        ret[0] = color[0] / 255;
        ret[1] = color[1] / 255;
        ret[2] = color[2] / 255;
      } else {
        ret[0] = color[0];
        ret[1] = color[1];
        ret[2] = color[2];
      }
      break;
    case 'undefined':
    case 'null':
      ret = [0, 0, 0];
  }
  return ret;
};

parseFont = function(fontStr) {
  var face, item, m, size, style, unit, _i, _len, _ref;
  if (fontStr == null) {
    fontStr = '';
  }
  style = 'regular';
  size = 16;
  face = 'Helvetica';
  _ref = fontStr.split(/\s+/g);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    item = _ref[_i];
    if (item === 'regular' || item === 'normal') {
      style = 'regular';
      continue;
    }
    if (item === 'italic' || item === 'oblique') {
      style = 'italic';
      continue;
    }
    if (item === 'bold') {
      style = 'bold';
      continue;
    }
    m = item.match(/^(\d*\.*\d+)(..)$/);
    if (m != null) {
      size = parseInt(m[1], 10);
      unit = m[2];
      switch (unit) {
        case 'pt':
        case 'px':
          break;
        case 'em':
        case 'en':
          size *= 16;
          break;
        case 'mm':
          size *= 72 / 25.4;
          break;
        case 'cm':
          size *= 72 / 2.54;
          break;
        case 'in':
          size *= 72;
          break;
        default:
          throw new Error("Invalid font unit: " + this.unit + " for font string " + fontStr);
      }
      continue;
    }
    face = item;
  }
  if (face === 'sans' || face === 'sans-serif' || face === 'sansserif') {
    face = 'Helvetica';
  }
  if (face === 'serif') {
    face = 'Times';
  }
  return [size, face, style];
};

getStyle = function(style) {
  switch (style) {
    case 'F':
      return 'f';
    case 'FD':
    case 'DF':
      return 'B';
    default:
      return 'S';
  }
};

/*
# Smart typeof function that will recognize builtin types as well as objects
# that are instances of those types.
*/


typeOf = function(obj) {
  var constructor, constructorName, guess, objectTypes, type;
  guess = typeof obj;
  if (guess !== 'object') {
    return guess;
  }
  if (obj === null) {
    return 'null';
  }
  objectTypes = {
    'array': Array,
    'boolean': Boolean,
    'number': Number,
    'string': String
  };
  for (type in objectTypes) {
    constructor = objectTypes[type];
    if (obj instanceof constructor) {
      return type;
    }
  }
  constructorName = obj.constructor.name;
  if (constructorName === 'Object') {
    return 'object';
  }
  return constructorName;
};

/*
# Creates a new Reference with a unique
# index.  The lowest index created will be startCount
*/


ReferenceFactory = (function() {

  ReferenceFactory.name = 'ReferenceFactory';

  function ReferenceFactory(startCount) {
    if (startCount == null) {
      startCount = 10;
    }
    this.currIndex = startCount;
    this.references = [];
  }

  ReferenceFactory.prototype.create = function() {
    var ref;
    ref = new Reference(this.currIndex, 0);
    this.currIndex += 1;
    this.references.push(ref);
    return ref;
  };

  return ReferenceFactory;

})();

/*
# Pdf reference
*/


Reference = (function() {

  Reference.name = 'Reference';

  function Reference(value, revision) {
    this.value = value != null ? value : 0;
    this.revision = revision != null ? revision : 0;
  }

  Reference.prototype.toString = function() {
    return "" + this.value + " " + this.revision + " R";
  };

  return Reference;

})();

/*
# Pdf dictionary
*/


Dictionary = (function() {

  Dictionary.name = 'Dictionary';

  function Dictionary(values) {
    var k;
    if (values == null) {
      values = {};
    }
    this.values = {};
    this.indent = '';
    for (k in values) {
      this.values[k] = values[k];
    }
  }

  Dictionary.prototype.set = function(key, value) {
    return this.values[key] = value;
  };

  Dictionary.prototype.get = function(key) {
    return this.values[key];
  };

  Dictionary.prototype.toString = function() {
    var indent, key, keysIndent, ret;
    indent = this.indent;
    keysIndent = indent + '\t';
    ret = indent + '<<\n';
    for (key in this.values) {
      ret += "" + keysIndent + key + " " + this.values[key] + "\n";
    }
    ret += indent + '>>';
    return ret;
  };

  return Dictionary;

})();

/*
# Pdf array.  This class is useful if you want to give an array as value
# of the dictionary, but you want to change the contents of the array later
# on.
*/


PdfArray = (function() {

  PdfArray.name = 'PdfArray';

  function PdfArray(values) {
    if (values == null) {
      values = [];
    }
    this.values = values.slice();
    this.length = values.length;
  }

  PdfArray.prototype.push = function(value) {
    this.values.push(value);
    return this.length = this.values.length;
  };

  PdfArray.prototype.get = function(key) {
    return this.values[key];
  };

  PdfArray.prototype.toString = function() {
    return "[" + (this.values.join(' ')) + "]";
  };

  return PdfArray;

})();

/*
# Pdf graphics context.  This class has all the basic pdf drawing operations built
# in.  The API is modeled after the canvas API
*/


PdfContex = (function() {

  PdfContex.name = 'PdfContex';

  PdfContex.prototype.lineWidth = 0.200025;

  PdfContex.prototype._capAndJoinStyles = {
    0: 0,
    miter: 0,
    butt: 0,
    1: 1,
    round: 1,
    2: 2,
    bevel: 2,
    projecting: 2,
    square: 2
  };

  function PdfContex(width, height, fontList) {
    this.width = width != null ? width : -1;
    this.height = height != null ? height : -1;
    this.fontList = fontList != null ? fontList : {};
    this.stream = '';
    this.propHistory = {};
  }

  PdfContex.prototype.toString = function() {
    return '' + this.stream;
  };

  PdfContex.prototype._hasChanged = function(prop) {
    if ((this[prop] != null) && !(this.propHistory[prop] != null)) {
      return true;
    }
    if (this[prop] !== this.propHistory[prop]) {
      return true;
    } else {
      return false;
    }
  };

  PdfContex.prototype._recordProp = function(prop) {
    if (this[prop].slice != null) {
      return this.propHistory[prop] = this[prop].slice();
    } else {
      return this.propHistory[prop] = this[prop];
    }
  };

  PdfContex.prototype._getIfUpdatedAndTouch = function(prop) {
    var ret;
    ret = null;
    if (this._hasChanged(prop)) {
      ret = this[prop];
      this._recordProp(prop);
    }
    return ret;
  };

  PdfContex.prototype._arcCoords = function(x, y, r, startAngle, endAngle) {
    var c, p, s, theta, x0, x1, x2, x3, y0, y1, y2, y3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    theta = endAngle - startAngle;
    x0 = Math.cos(theta / 2);
    y0 = Math.sin(theta / 2);
    x3 = x0;
    y3 = -y0;
    x1 = (4 - x0) / 3;
    y1 = (1 - x0) * (3 - x0) / (3 * y0);
    x2 = x1;
    y2 = -y1;
    s = Math.sin(-(startAngle + theta / 2));
    c = Math.cos(-(startAngle + theta / 2));
    _ref = [c * x0 - s * y0, s * x0 + c * y0], x0 = _ref[0], y0 = _ref[1];
    _ref1 = [c * x1 - s * y1, s * x1 + c * y1], x1 = _ref1[0], y1 = _ref1[1];
    _ref2 = [c * x2 - s * y2, s * x2 + c * y2], x2 = _ref2[0], y2 = _ref2[1];
    _ref3 = [c * x3 - s * y3, s * x3 + c * y3], x3 = _ref3[0], y3 = _ref3[1];
    _ref4 = (function() {
      var _i, _len, _ref4, _results;
      _ref4 = [x0, x1, x2, x3, y0, y1, y2, y3];
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        p = _ref4[_i];
        _results.push(p * r);
      }
      return _results;
    })(), x0 = _ref4[0], x1 = _ref4[1], x2 = _ref4[2], x3 = _ref4[3], y0 = _ref4[4], y1 = _ref4[5], y2 = _ref4[6], y3 = _ref4[7];
    _ref5 = (function() {
      var _i, _len, _ref5, _results;
      _ref5 = [x0, x1, x2, x3];
      _results = [];
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        p = _ref5[_i];
        _results.push(p + x);
      }
      return _results;
    })(), x0 = _ref5[0], x1 = _ref5[1], x2 = _ref5[2], x3 = _ref5[3];
    _ref6 = (function() {
      var _i, _len, _ref6, _results;
      _ref6 = [y0, y1, y2, y3];
      _results = [];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        p = _ref6[_i];
        _results.push(p + y);
      }
      return _results;
    })(), y0 = _ref6[0], y1 = _ref6[1], y2 = _ref6[2], y3 = _ref6[3];
    return [x0, y0, x1, y1, x2, y2, x3, y3];
  };

  /*
      # State modifiers
  */


  PdfContex.prototype.save = function() {
    return this.stream += '\n' + 'q';
  };

  PdfContex.prototype.restore = function() {
    return this.stream += '\n' + 'Q';
  };

  /*
      # Transformations
  */


  PdfContex.prototype.transform = function(a, b, c, d, e, f) {
    var p, points;
    points = (function() {
      var _i, _len, _ref, _results;
      _ref = [a, b, c, d, e, f];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(round2(p));
      }
      return _results;
    })();
    return this.stream += '\n' + ("" + (points.join(' ')) + " cm");
  };

  PdfContex.prototype.scale = function(x, y) {
    return this.transform(x, 0, 0, y, 0, 0);
  };

  PdfContex.prototype.translate = function(x, y) {
    return this.transform(0, 0, 0, 0, x, y);
  };

  PdfContex.prototype.rotate = function(theta) {
    return this.transform(Math.cos(theta), Math.sin(theta), -Math.sin(theta), Math.cos(theta), 0, 0);
  };

  /*
      # Path operations
  */


  PdfContex.prototype.moveTo = function(x, y) {
    if (this.height > 1) {
      y = this.height - y;
    }
    return this.stream += '\n' + ("" + (round2(x)) + " " + (round2(y)) + " m");
  };

  PdfContex.prototype.lineTo = function(x, y) {
    if (this.height > 1) {
      y = this.height - y;
    }
    return this.stream += '\n' + ("" + (round2(x)) + " " + (round2(y)) + " l");
  };

  PdfContex.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
    var p, points;
    if (this.height > 1) {
      y1 = this.height - y1;
    }
    if (this.height > 1) {
      y2 = this.height - y2;
    }
    if (this.height > 1) {
      y3 = this.height - y3;
    }
    points = (function() {
      var _i, _len, _ref, _results;
      _ref = [x1, y1, x2, y2, x3, y3];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(round2(p));
      }
      return _results;
    })();
    return this.stream += '\n' + ("" + (points.join(' ')) + " c");
  };

  PdfContex.prototype.closePath = function() {
    return this.stream += '\n' + 'h';
  };

  PdfContex.prototype.beginPath = function() {
    return this.stream += '\n' + 'n';
  };

  /*
      # Stroking and Filling operations
  */


  PdfContex.prototype.stroke = function() {
    var cap, color, join, lineWidth, out;
    out = '';
    color = this._getIfUpdatedAndTouch('strokeStyle');
    if (color != null) {
      color = parseColor(color);
      out += " " + (round3(color[0])) + " " + (round3(color[1])) + " " + (round3(color[2])) + " RG";
    }
    lineWidth = this._getIfUpdatedAndTouch('lineWidth');
    if (lineWidth != null) {
      out += " " + (round3(lineWidth)) + " w";
    }
    cap = this._getIfUpdatedAndTouch('lineCap');
    if (cap != null) {
      cap = this._capAndJoinStyles[cap];
      out += " " + cap + " J";
    }
    join = this._getIfUpdatedAndTouch('lineJoin');
    if (join != null) {
      join = this._capAndJoinStyles[join];
      out += " " + join + " j";
    }
    return this.stream += '\n' + out + ' S';
  };

  PdfContex.prototype.fill = function() {
    var color, out;
    out = '';
    color = this._getIfUpdatedAndTouch('fillStyle');
    if (color != null) {
      color = parseColor(color);
      out += " " + (round3(color[0])) + " " + (round3(color[1])) + " " + (round3(color[2])) + " rg";
    }
    return this.stream += '\n' + out + ' f';
  };

  PdfContex.prototype.fillAndStroke = function() {
    var cap, color, join, lineWidth, out;
    out = '';
    color = this._getIfUpdatedAndTouch('strokeStyle');
    if (color != null) {
      color = parseColor(color);
      out += " " + (round3(color[0])) + " " + (round3(color[1])) + " " + (round3(color[2])) + " RG";
    }
    color = this._getIfUpdatedAndTouch('fillStyle');
    if (color != null) {
      color = parseColor(color);
      out += " " + (round3(color[0])) + " " + (round3(color[1])) + " " + (round3(color[2])) + " rg";
    }
    lineWidth = this._getIfUpdatedAndTouch('lineWidth');
    if (lineWidth != null) {
      out += " " + (round3(lineWidth)) + " w";
    }
    cap = this._getIfUpdatedAndTouch('lineCap');
    if (cap != null) {
      cap = this._capAndJoinStyles[cap];
      out += " " + cap + " J";
    }
    join = this._getIfUpdatedAndTouch('lineJoin');
    if (join != null) {
      join = this._capAndJoinStyles[join];
      out += " " + join + " j";
    }
    return this.stream += '\n' + out + ' B';
  };

  /*
      # Shapes
  */


  PdfContex.prototype.rect = function(x, y, w, h) {
    var out;
    if (this.height > 1) {
      y = this.height - y;
    }
    out = "" + (round2(x)) + " " + (round2(y)) + " " + (round2(w)) + " " + (round2(-h)) + " re";
    return this.stream += '\n' + out;
  };

  PdfContex.prototype.ellipse = function(x, y, rx, ry) {
    var kappa, ox, oy, xe, xm, ye, ym;
    kappa = .5522848;
    ox = (rx / 2) * kappa;
    oy = (ry / 2) * kappa;
    xe = x + rx;
    ye = y + ry;
    xm = x + rx / 2;
    ym = y + ry / 2;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    return this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  };

  PdfContex.prototype.arc = function(x, y, r, startAngle, endAngle, anticlockwise) {
    var c, coord, coords, _i, _len, _results;
    if (anticlockwise == null) {
      anticlockwise = true;
    }
    coords = [];
    while (endAngle - startAngle > Math.PI / 2) {
      coords.push(this._arcCoords(x, y, r, startAngle, startAngle + Math.PI / 2));
      startAngle += Math.PI / 2;
    }
    coords.push(this._arcCoords(x, y, r, startAngle, endAngle));
    if (anticlockwise === false) {
      throw new Error('clockwise arcs not implimented yet');
      coords = (function() {
        var _i, _len, _ref, _results;
        _ref = coords.reverse();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(c.reverse());
        }
        return _results;
      })();
    }
    this.moveTo(coords[0][0], coords[0][1]);
    _results = [];
    for (_i = 0, _len = coords.length; _i < _len; _i++) {
      coord = coords[_i];
      _results.push(this.bezierCurveTo.apply(this, coord.slice(2)));
    }
    return _results;
  };

  /*
      # Text
  */


  PdfContex.prototype.fillText = function(x, y, text) {
    var color, currentFont, face, out, size, style, t, _ref;
    if (this.height > 1) {
      y = this.height - y;
    }
    /*
            # Inserts something like this into PDF
                BT
                /F1 16 Tf  % Font name + size
                16 TL % How many units down for next line in multiline text
                0 g % color
                28.35 813.54 Td % position
                (line one) Tj
                T* (line two) Tj
                T* (line three) Tj
                ET
    */

    switch (typeOf(text)) {
      case 'string':
        text = text.split(/\r\n|\r|\n/g);
        break;
      case 'array':
        break;
      default:
        throw new Error("Unknown text type for fillText " + text);
    }
    text = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = text.length; _i < _len; _i++) {
        t = text[_i];
        _results.push(pdfEscape(t));
      }
      return _results;
    })();
    _ref = parseFont(this.font), size = _ref[0], face = _ref[1], style = _ref[2];
    currentFont = this.fontList[face];
    if (!(currentFont != null)) {
      throw new Error("Font face " + face + " not in fontList");
    }
    color = parseColor(this['fillStyle']);
    out = "BT\n";
    out += "\t" + currentFont + " " + (round3(size)) + " Tf\n";
    out += "\t" + (round3(size)) + " TL\n";
    out += "\t" + (round3(color[0])) + " " + (round3(color[1])) + " " + (round3(color[2])) + " rg";
    out += "\t" + (round2(x)) + " " + (round2(y)) + " Td\n";
    out += "\t(" + (text.join(') Tj\nT* (')) + ") Tj\n";
    out += "ET";
    return this.stream += '\n' + out;
  };

  /*
      # Images
  */


  PdfContex.prototype.drawImage = function() {
    var dHeight, dWidth, dx, dy, h, image, params, sHeight, sWidth, sx, sy, w, x, y;
    image = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    switch (params.length) {
      case 2:
        x = params[0], y = params[1];
        w = 1;
        h = 1;
        break;
      case 4:
        x = params[0], y = params[1], w = params[2], h = params[3];
        break;
      case 8:
        sx = params[0], sy = params[1], sWidth = params[2], sHeight = params[3], dx = params[4], dy = params[5], dWidth = params[6], dHeight = params[7];
        throw new Error("Image slicing not implimented yet");
        break;
      default:
        throw new Error("Improper number of arguments to drawImage: " + image + "," + params);
    }
    switch (typeOf(image)) {
      case 'string':
        if (image.charAt(0) !== '/') {
          throw new Error("image must be an image reference starting with '/'");
        }
        break;
      default:
        throw new Error("image must be an image reference starting with '/', not " + image);
    }
    if (this.height > 1) {
      y = this.height - y;
    }
    this.save();
    this.transform(w, 0, 0, h, x, y - h);
    this.stream += '\n' + ("" + image + " Do");
    return this.restore();
  };

  return PdfContex;

})();

/*
# Pdf object. If stream is left empty the object will be formatted as
#   @reference obj
#     @value
#   endobj
#
# If a stream is given, it is assume that @value is a Dictionary.  The
# '/Length' entry of @value will be set to the length of stream and the
# output will be
#   @reference obj
#     @value
#   stream
#   @stream
#   endstream
#   endobj
*/


PdfObject = (function() {

  PdfObject.name = 'PdfObject';

  function PdfObject(reference, value, stream) {
    this.reference = reference != null ? reference : new Reference;
    this.value = value;
    this.stream = stream;
    if (this.stream != null) {
      if (typeOf(this.value) !== 'Dictionary') {
        throw new Error("The value of an object with a stream must be a Dictionary type");
      }
    }
  }

  PdfObject.prototype.toString = function() {
    var ret, streamContents;
    ret = "" + this.reference.value + " " + this.reference.revision + " obj\n";
    streamContents = '' + this.stream;
    if (this.stream != null) {
      this.value.set('/Length', streamContents.length);
    }
    ret += "" + this.value + "\n";
    if (this.stream != null) {
      ret += "stream\n";
      ret += "" + streamContents + "\n";
      ret += "endstream\n";
    }
    ret += "endobj";
    return ret;
  };

  return PdfObject;

})();

PdfImage = (function() {

  PdfImage.name = 'PdfImage';

  function PdfImage(imageData, format, width, height) {
    var _ref;
    this.imageData = imageData;
    this.format = format;
    this.width = width != null ? width : -1;
    this.height = height != null ? height : -1;
    this.format = this.format.toUpperCase();
    switch (this.format) {
      case 'JPEG':
        if (this.width === -1 || this.height === -1) {
          _ref = getJpegSize(this.imageData), this.width = _ref[0], this.height = _ref[1];
        }
        break;
      default:
        if (this.width === -1 || this.height === -1) {
          throw new Error("Image dimensions must be explicitly specified for format " + this.format);
        }
    }
  }

  PdfImage.prototype.toString = function() {
    return '' + this.imageData;
  };

  return PdfImage;

})();

jsPDF = (function() {

  jsPDF.name = 'jsPDF';

  jsPDF.prototype.jsPDFVersion = '20120623';

  jsPDF.prototype.pdfVersion = '1.4';

  jsPDF.prototype.pageFormats = {
    'a3': [841.89, 1190.55],
    'a4': [595.28, 841.89],
    'a5': [420.94, 595.28],
    'letter': [612, 792],
    'legal': [612, 1008]
  };

  jsPDF.prototype.API = {};

  function jsPDF(orientation, unit, format) {
    var catalogdict, fontName, infodict, pagesdict, resourcesdict, _i, _len, _ref, _ref1;
    if (orientation == null) {
      orientation = 'portrait';
    }
    this.unit = unit != null ? unit : 'mm';
    this.format = format != null ? format : 'letter';
    if (this.API) {
      this._extendAPI(this.API);
    }
    this.pdfcontents = [];
    this.referenceFactory = new ReferenceFactory(10);
    switch (this.unit) {
      case 'pt':
        this.scale = 1;
        break;
      case 'mm':
        this.scale = 72 / 25.4;
        break;
      case 'cm':
        this.scale = 72 / 2.54;
        break;
      case 'in':
        this.scale = 72;
        break;
      default:
        throw new Error("Invalid unit: " + this.unit);
    }
    switch (orientation.toLowerCase()) {
      case 'portrait':
      case 'p':
        this.orientation = 'portriat';
        break;
      case 'landscape':
      case 'l':
        this.orientation = 'landscape';
        break;
      default:
        throw new Error("Unknown orientation: " + orientation);
    }
    switch (typeOf(this.format)) {
      case 'array':
        this.pageWidth = format[0] * this.scale;
        this.pageHeight = format[1] * this.scale;
        this.orientation = 'custom';
        break;
      case 'string':
        if (!(this.format in this.pageFormats)) {
          throw new Error("Unknown page format: " + this.format);
        }
        _ref = this.pageFormats[this.format], this.pageWidth = _ref[0], this.pageHeight = _ref[1];
        break;
      default:
        throw new Error("Unknown page format: " + this.format);
    }
    /*
            # set up other instance-level variables
    */

    this.pdfPrefix = ("%PDF-" + this.pdfVersion + "\n%") + String.fromCharCode(200) + String.fromCharCode(201) + String.fromCharCode(202) + String.fromCharCode(203);
    this.pdfSuffix = "%%EOF";
    this.objectList = [];
    this.fontList = {};
    this.imageList = [];
    this.pageReferences = new PdfArray;
    this.pageList = [];
    pagesdict = {
      '/Type': '/Pages',
      '/Kids': this.pageReferences,
      '/Count': 0,
      '/MediaBox': "[0 0 " + this.pageWidth + " " + this.pageHeight + "]"
    };
    this.pagesObject = new PdfObject(new Reference(1, 0), new Dictionary(pagesdict));
    this.fontDict = new Dictionary();
    this.xobjectDict = new Dictionary();
    resourcesdict = {
      '/ProcSet': '[/PDF /Text /ImageB /ImageC /ImageI]',
      '/Font': this.fontDict,
      '/XObject': this.xobjectDict
    };
    this.resourcesObject = new PdfObject(new Reference(2, 0), new Dictionary(resourcesdict));
    catalogdict = {
      '/Type': '/Catalog',
      '/Pages': this.pagesObject.reference,
      '/PageLayout': '/OneColumn'
    };
    this.catalogObject = new PdfObject(this.referenceFactory.create(), new Dictionary(catalogdict));
    infodict = {
      '/Producer': "(jsPDF " + this.jsPDFVersion + ")",
      '/CreationDate': "(D:" + (getISODate()) + ")"
    };
    this.infoObject = new PdfObject(this.referenceFactory.create(), new Dictionary(infodict));
    /*
            # update the objectList to have all the objects we just created
    */

    this.objectList.push(this.pagesObject);
    this.objectList.push(this.resourcesObject);
    this.objectList.push(this.catalogObject);
    this.objectList.push(this.infoObject);
    /*
            # Initialize our current pdf document with fonts and a page
    */

    _ref1 = ['Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique', 'Helvetica-BoldOblique', 'Courier', 'Courier-Bold', 'Courier-Oblique', 'Courier-BoldOblique', 'Times-Roman', 'Times-Bold', 'Times-Italic', 'Times-BoldItalic'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      fontName = _ref1[_i];
      this.addFont(fontName);
    }
    this.addPage();
  }

  jsPDF.prototype._extendAPI = function(newAPI) {
    var method, methodName, _results;
    _results = [];
    for (methodName in newAPI) {
      method = newAPI[methodName];
      if (newAPI.hasOwnProperty(methodName)) {
        _results.push(this[methodName] = method);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  jsPDF.prototype.addPage = function() {
    var context, newpage, newpagecontent, pagecontentref, pagedict, pageref;
    pageref = this.referenceFactory.create();
    pagecontentref = this.referenceFactory.create();
    context = new PdfContex(this.pageWidth, this.pageHeight, this.fontList);
    newpagecontent = new PdfObject(pagecontentref, new Dictionary, context);
    pagedict = {
      '/Type': '/Page',
      '/Parent': this.pagesObject.reference,
      '/Resources': this.resourcesObject.reference,
      '/Contents': newpagecontent.reference
    };
    newpage = new PdfObject(pageref, new Dictionary(pagedict));
    this.pageList.push(newpage);
    this.pageReferences.push(pageref);
    this.pagesObject.value.set('/Count', this.pageReferences.length);
    this.currentPageContents = newpagecontent;
    this.objectList.push(newpage);
    this.objectList.push(newpagecontent);
    return this;
  };

  jsPDF.prototype.addFont = function(fontName) {
    var font, fontId, fontdict;
    if (!(fontName === 'Helvetica' || fontName === 'Helvetica-Bold' || fontName === 'Helvetica-Oblique' || fontName === 'Helvetica-BoldOblique' || fontName === 'Courier' || fontName === 'Courier-Bold' || fontName === 'Courier-Oblique' || fontName === 'Courier-BoldOblique' || fontName === 'Times-Roman' || fontName === 'Times-Bold' || fontName === 'Times-Italic' || fontName === 'Times-BoldItalic')) {
      throw new Error("Unknown font " + fontName + ".  External fonts not supported yet.");
    }
    if (this.fontList[fontName] != null) {
      return;
    }
    fontdict = {
      '/Type': '/Font',
      '/BaseFont': "/" + fontName,
      '/Subtype': '/Type1',
      '/Encoding': '/WinAnsiEncoding'
    };
    font = new PdfObject(this.referenceFactory.create(), new Dictionary(fontdict));
    fontId = '/F' + (Object.keys(this.fontList).length + 1);
    this.fontDict.set(fontId, font.reference);
    this.fontList[fontName] = fontId;
    this.objectList.push(font);
    return this;
  };

  jsPDF.prototype.addImageResource = function(imageData, format) {
    var image, imageObj, imageReferece, imagedict;
    if (format.toUpperCase() !== 'JPEG') {
      throw new Error('currently only JPEG format is supported for images');
    }
    image = new PdfImage(imageData, format);
    image.name = "/I" + (this.imageList.length + 1);
    this.imageList.push(image);
    imagedict = {
      '/Type': '/XObject',
      '/Subtype': '/Image',
      '/Width': image.width,
      '/Height': image.height,
      '/ColorSpace': '/DeviceRGB',
      '/BitsPerComponent': '8',
      '/Filter': '/DCTDecode'
    };
    imageReferece = this.referenceFactory.create();
    imageObj = new PdfObject(imageReferece, new Dictionary(imagedict), image);
    this.objectList.push(imageObj);
    this.xobjectDict.set(image.name, imageReferece);
    return image;
  };

  jsPDF.prototype.setProperties = function(props) {
    var keys, p;
    keys = {
      'title': '/Title',
      'subject': '/Subject',
      'author': '/Author',
      'keywords': '/Keywords',
      'creator': '/Creator'
    };
    for (p in props) {
      if (p in keys) {
        this.infoObject.value.set(keys[p], "(" + (pdfEscape(props[p])) + ")");
      }
    }
    return this;
  };

  jsPDF.prototype._buildOutput = function() {
    var obj, out, trailerdict, xrefLocations, xrefStart, _i, _len, _ref;
    out = this.pdfPrefix + '\n';
    xrefLocations = [];
    _ref = this.objectList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      obj = _ref[_i];
      xrefLocations.push(out.length);
      out += obj + '\n';
    }
    /*
            # Put in the xref table
    */

    out += '\n';
    xrefStart = out.length;
    out += this._buildXref(xrefLocations);
    trailerdict = {
      '/Size': xrefLocations.length + 1,
      '/Root': this.catalogObject.reference,
      '/Info': this.infoObject.reference
    };
    out += '\ntrailer\n';
    out += new Dictionary(trailerdict);
    out += '\nstartxref\n';
    out += xrefStart + '\n';
    return out += this.pdfSuffix;
  };

  jsPDF.prototype._buildXref = function(xrefLocations) {
    var n, padd10, ret, _i, _len;
    padd10 = function(num) {
      var ret;
      ret = num.toFixed(0);
      if (ret.length >= 10) {
        return ret;
      }
      return Array(11 - ret.length).join('0') + ret;
    };
    ret = 'xref\n';
    ret += "0 " + (xrefLocations.length + 1) + "\n";
    ret += '0000000000 65535 f ';
    for (_i = 0, _len = xrefLocations.length; _i < _len; _i++) {
      n = xrefLocations[_i];
      ret += '\n';
      ret += "" + (padd10(n)) + " 00000 n ";
    }
    return ret;
  };

  jsPDF.prototype.output = function(type, options) {
    var data;
    if (type == null) {
      type = 'string';
    }
    switch (type) {
      case 'string':
        return this._buildOutput();
      case 'datauristring':
      case 'dataurlstring':
        return 'data:application/pdf;base64,' + base64encode(this._buildOutput());
      case 'datauri':
      case 'dataurl':
        data = 'data:application/pdf;base64,' + base64encode(this._buildOutput());
        document.location.href = data;
        break;
      default:
        throw new Error("Output type " + type + " not supported.");
    }
    return this;
  };

  return jsPDF;

})();

/*
# Set up an implimentation of the original jsPDF API.  This is the default
# api for jsPDF, but it can easily be swapped out or extened to suit one's tastes
*/


jsPDFOriginalAPI = {
  _applyStyle: function(style) {
    switch (style) {
      case 'F':
        return this.currentPageContents.stream.fill();
      case 'FD':
      case 'DF':
        return this.currentPageContents.stream.fillAndStroke();
      default:
        return this.currentPageContents.stream.stroke();
    }
  },
  _fontLookup: {
    'helvetica': {
      'normal': 'Helvetica',
      'bold': 'Helvetica-Bold',
      'italic': 'Helvetica-Oblique',
      'bolditalic': 'Helvetica-BoldOblique'
    },
    'courier': {
      'normal': 'Courier',
      'bold': 'Courier-Bold',
      'italic': 'Courier-Oblique',
      'bolditalic': 'Courier-BoldOblique'
    },
    'times': {
      'normal': 'Times-Roman',
      'bold': 'Times-Bold',
      'italic': 'Times-Italic',
      'bolditalic': 'Times-BoldItalic'
    }
  },
  defaultFont: 'Helvetica',
  defaultFontColor: [0, 0, 0],
  defaultFontSize: 16,
  setFont: function(fontName) {
    if (fontName in this.fontList) {
      this.currentFont = fontName;
      this.currentFontFamilyName = null;
    } else if (fontName.toLowerCase() in this._fontLookup) {
      this.currentFontFamilyName = fontName.toLowerCase();
    } else {
      throw new Error("Unknown font: " + fontName + "; It must first be added with addFont");
    }
    return this;
  },
  setFontSize: function(size) {
    this.currentFontSize = size;
    return this;
  },
  setFontType: function(type) {
    if (type === 'normal' || type === 'italic' || type === 'bold' || type === 'bolditalic') {
      this.currentFontType = type;
    } else {
      throw new Error("Unknown font type: " + type);
    }
    return this;
  },
  setTextColor: function(r, g, b) {
    if (r == null) {
      r = 0;
    }
    if (g != null) {
      this.currentFontColor = [r, g, b];
    } else {
      this.currentFontColor = [r, r, r];
    }
    return this;
  },
  setDrawColor: function(r, g, b) {
    if (g != null) {
      this.currentPageContents.stream.strokeStyle = [r, g, b];
    } else {
      this.currentPageContents.stream.strokeStyle = [r, r, r];
    }
    return this;
  },
  setFillColor: function(r, g, b) {
    if (g != null) {
      this.currentPageContents.stream.fillStyle = [r, g, b];
    } else {
      this.currentPageContents.stream.fillStyle = [r, r, r];
    }
    return this;
  },
  setLineWidth: function(width) {
    this.currentPageContents.stream.lineWidth = width * this.scale;
    return this;
  },
  setLineCap: function(style) {
    this.currentPageContents.stream.lineCap = style;
    return this;
  },
  setLineJoin: function(style) {
    this.currentPageContents.stream.lineJoin = style;
    return this;
  },
  /**
   * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
   * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
   * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
   * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
   * @function
   * @returns {jsPDF}
   * @name jsPDF.text
  */

  text: function(x, y, text) {
    var fontType;
    x = x * this.scale;
    y = y * this.scale;
    if (!(this.currentFontSize != null)) {
      this.setFontSize(this.defaultFontSize);
    }
    if (!(this.currentFont != null) && !(this.currentFontFamilyName != null)) {
      this.setFont(this.defaultFont);
    }
    if (!(this.currentFontColor != null)) {
      this.setTextColor.apply(this, this.defaultFontColor);
    }
    fontType = this.currentFontType != null ? this.currentFontType : 'normal';
    if (this.currentFontFamilyName != null) {
      this.currentFont = this._fontLookup[this.currentFontFamilyName][fontType];
    }
    this.currentPageContents.stream.font = "" + this.currentFontSize + "pt " + this.currentFont;
    this.currentPageContents.stream.fillStyle = this.currentFontColor;
    this.currentPageContents.stream.fillText(x, y, text);
    return this;
  },
  line: function(x1, y1, x2, y2) {
    x1 = x1 * this.scale;
    y1 = y1 * this.scale;
    x2 = x2 * this.scale;
    y2 = y2 * this.scale;
    this.currentPageContents.stream.moveTo(x1, y1);
    this.currentPageContents.stream.lineTo(x2, y2);
    this.currentPageContents.stream.stroke();
    return this;
  },
  /**
   * Adds series of curves (straight lines or cubic bezier curves) to canvas,
   * starting at `x`, `y` coordinates.
   * All data points in `lines` are relative to last line origin.
   * `x`, `y` become x1,y1 for first line / curve in the set.
   * For lines you only need to specify [x2, y2] - (ending point) vector
   * against x1, y1 starting point.
   * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control
   * points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.
   *
   * @example .lines(212,110,[[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 10) // line, line, bezier curve, line
   * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
   * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
   * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
   * @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
   * @function
   * @returns {jsPDF}
   * @name jsPDF.text
  */

  lines: function(x, y, lines, scale, style) {
    var basex, basey, p, scalex, scaley, x2, x3, y2, y3, _i, _len;
    scalex = this.scale;
    scaley = this.scale;
    switch (typeOf(scale)) {
      case 'number':
        scalex *= scale;
        scaley *= scale;
        break;
      case 'array':
        scalex *= scale[0];
        scaley *= scale[1];
    }
    basex = x * scalex;
    basey = y * scaley;
    this.currentPageContents.stream.moveTo(basex, basey);
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      p = lines[_i];
      switch (p.length) {
        case 2:
          basex += p[0] * scalex;
          basey += p[1] * scaley;
          this.currentPageContents.stream.lineTo(basex, basey);
          break;
        case 6:
          x2 = p[0] * scalex + basex;
          y2 = p[1] * scaley + basey;
          x3 = p[2] * scalex + basex;
          y3 = p[3] * scaley + basey;
          basex = p[4] * scalex + basex;
          basey = p[5] * scaley + basey;
          this.currentPageContents.stream.bezierCurveTo(x2, y2, x3, y3, basex, basey);
          break;
        default:
          throw new Error("Unknown type of line " + p + "; Should specify 2 or 6 coordinates.");
      }
    }
    this._applyStyle(style);
    return this;
  },
  rect: function(x, y, w, h, style) {
    x = x * this.scale;
    y = y * this.scale;
    w = w * this.scale;
    h = h * this.scale;
    this.currentPageContents.stream.rect(x, y, w, h);
    this._applyStyle(style);
    return this;
  },
  triangle: function(x1, y1, x2, y2, x3, y3, style) {
    var c, _ref;
    _ref = (function() {
      var _i, _len, _ref, _results;
      _ref = [x1, y1, x2, y2, x3, y3];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c * this.scale);
      }
      return _results;
    }).call(this), x1 = _ref[0], y1 = _ref[1], x2 = _ref[2], y2 = _ref[3], x3 = _ref[4], y3 = _ref[5];
    this.currentPageContents.stream.moveTo(x1, y1);
    this.currentPageContents.stream.lineTo(x2, y2);
    this.currentPageContents.stream.lineTo(x3, y3);
    this.currentPageContents.stream.closePath();
    this._applyStyle(style);
    return this;
  },
  ellipse: function(x, y, rx, ry, style) {
    x = x * this.scale;
    y = y * this.scale;
    rx = rx * this.scale;
    ry = ry * this.scale;
    this.currentPageContents.stream.ellipse(x, y, rx, ry);
    this._applyStyle(style);
    return this;
  },
  circle: function(x, y, r, style) {
    this.ellipse(x, y, r, r, style);
    return this;
  },
  addImage: function(image, format, x, y, w, h) {
    if (w == null) {
      w = 72;
    }
    if (h == null) {
      h = 72;
    }
    x = x * this.scale;
    y = y * this.scale;
    w = w * this.scale;
    h = h * this.scale;
    image = this.addImageResource(image, format);
    return this.currentPageContents.stream.drawImage(image.name, x, y, w, h);
  }
};

/*
# Set the jsPDF API
#
# This must be done to the prototype!
*/


jsPDF.prototype.API = jsPDFOriginalAPI;

/*
# Attach jsPDF to the global scope manually, in case it is wrapped in a closure.
# We do this in a way compatible with both the browser and node.js
*/


try {
  root = typeof exports !== "undefined" && exports !== null ? exports : this;
  root.jsPDF = jsPDF;
} catch (e) {

}
